<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Tiles — Hover (Desktop) / Tap (Mobile) + Building Hand-Eye Coordination and Motor Skills </title>
  <style>
    :root { color-scheme: dark; }
    body{
      margin:0; min-height:100vh; display:grid; place-items:center;
      background:#0b0b10; color:#eaeaf2;
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      user-select:none; -webkit-user-select:none;
    }
    .wrap{ width:min(580px, 94vw); }
    .top{
      display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap;
      margin-bottom:10px;
    }
    .pill{
      padding:6px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,0.14);
      background:rgba(255,255,255,0.06);
      font-size:12px; opacity:0.92;
    }
    .game{
      position:relative;
      height: 700px;
      border-radius: 20px;
      border:1px solid rgba(255,255,255,0.14);
      overflow:hidden;
      background: linear-gradient(180deg, rgba(80,190,220,0.35), rgba(20,20,28,0.0) 55%, rgba(20,20,28,0.35));
      box-shadow:0 10px 35px rgba(0,0,0,0.35);
      cursor: crosshair;
      touch-action: manipulation;
    }
    canvas{ width:100%; height:100%; display:block; }
    .overlay{
      position:absolute; inset:0;
      pointer-events:none;
      display:flex; flex-direction:column; justify-content:space-between;
      padding:10px;
      text-shadow: 0 2px 10px rgba(0,0,0,0.7);
    }
    .hudrow{
      display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap;
      align-items:center;
    }
    .chip{
      font-size:13px; font-weight:700;
      background: rgba(0,0,0,0.22);
      border:1px solid rgba(255,255,255,0.10);
      border-radius: 999px;
      padding:6px 10px;
    }
    .centerHint{
      margin: 0 auto;
      width: min(500px, 92%);
      text-align:center;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.22);
      font-weight:800;
      letter-spacing:0.3px;
    }
    .big{ font-size:22px; }
    .controls{
      margin-top:10px;
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    }
    button{
      border:1px solid rgba(255,255,255,0.14);
      background:rgba(255,255,255,0.06);
      color:#fff; border-radius:12px;
      padding:10px 12px; cursor:pointer;
    }
    .status{
      margin-top:10px; padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,0.14);
      background:rgba(255,255,255,0.05);
    }
    .ok{ border-color: rgba(76,175,80,0.35); background: rgba(76,175,80,0.10); }
    .bad{ border-color: rgba(244,67,54,0.35); background: rgba(244,67,54,0.10); }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <span class="pill">Mode: <span id="mode">—</span></span>
      <span class="pill">Score: <span id="score">0</span></span>
      <span class="pill">Best: <span id="best">0</span></span>
      <span class="pill">Speed: <span id="spd">1.00×</span></span>
      <span class="pill">Window: <span id="win">100</span>%</span>
    </div>

    <div class="game" id="game">
      <canvas id="cv"></canvas>

      <div class="overlay">
        <div class="hudrow">
          <div class="chip">Tiles + Building Hand-Eye Coordination and Motor Skills </div>
          <div class="chip" id="hudRight">Ready</div>
        </div>

        <div class="centerHint" id="centerHint">
          Press <b>Start</b> (audio). Then follow instruction.
        </div>

        <div class="hudrow">
          <div class="chip" id="noteHint">Next note: —</div>
          <div class="chip" id="stepHint">Step: 0</div>
        </div>
      </div>
    </div>

    <div class="controls">
      <button id="startBtn">Start (Audio + Game)</button>
      <button id="resetBtn">Reset</button>
    </div>

    <div id="status" class="status">
      The highlighted lane acceptance zone covers **75%** or more of the screen height.
    </div>
  </div>

  <script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>
  <script>
  (() => {
    // INPUT MODE
    const CAN_HOVER = window.matchMedia("(hover: hover)").matches;
    const INPUT_MODE = CAN_HOVER ? "hover" : "tap";
    document.getElementById("mode").textContent = INPUT_MODE.toUpperCase();

    // CANVAS
    const gameEl = document.getElementById("game");
    const cv = document.getElementById("cv");
    const ctx = cv.getContext("2d");
    function resize(){
      const r = cv.getBoundingClientRect();
      cv.width  = Math.floor(r.width * devicePixelRatio);
      cv.height = Math.floor(r.height * devicePixelRatio);
    }
    window.addEventListener("resize", resize);
    resize();

    // UI
    const scoreEl = document.getElementById("score");
    const bestEl  = document.getElementById("best");
    const spdEl   = document.getElementById("spd");
    const winEl   = document.getElementById("win");
    const statusEl= document.getElementById("status");
    const hudRight= document.getElementById("hudRight");
    const centerHint = document.getElementById("centerHint");
    const noteHint = document.getElementById("noteHint");
    const stepHint = document.getElementById("stepHint");
    function setStatus(t, kind=""){
      statusEl.className = "status " + kind;
      statusEl.textContent = t;
    }

    // BEST
    const BEST_KEY = "tiles_super_easy_best_v1";
    let best = Number(localStorage.getItem(BEST_KEY) || 0);
    bestEl.textContent = best;

    // AUDIO
    const synth = new Tone.Synth({
      oscillator: { type: "triangle" },
      envelope: { attack: 0.01, decay: 0.08, sustain: 0.2, release: 0.15 }
    }).toDestination();
    function playNote(note, speed){
      const dur = Math.max(0.12, 0.24 / speed);
      synth.triggerAttackRelease(note, dur);
    }

    // GEOMETRY
    const LANES = 4;
    const TOP_WIDTH_FRAC = 0.42;
    const BOT_WIDTH_FRAC = 0.96;
    const TRACK_TOP_Y_FRAC = 0.12;
    const TRACK_BOT_Y_FRAC = 0.98;

    const HIT_Y_FRAC = 0.86;
    const TILE_LENGTH_FRAC = 0.11;

    // ACCEPTANCE ZONE: ~75% of the screen height around the hit line
    function laneAcceptHalfHeight(tp){
      return tp.h * 0.375; // half-height = 37.5% => total height = 75%
    }

    // SPEED (still increases)
    const BASE_UNITS_PER_SEC = 0.58;
    let speed = 1.0;

    // HUGE timing window, and we DO NOT shrink it anymore
    const WIN_BASE = 0.090;  // very forgiving
    const WIN_MIN  = 0.090;  // constant window
    function currentWindow(){
      const w = WIN_MIN;
      winEl.textContent = "200"; // relative display (approx), just a friendly indicator
      return w;
    }

    function speedGain(){
      return 0.025; // constant gain per hit
    }

    // MUSIC (Minuet-like melody line, simplified & looped)
    const MELODY = [
      "G4","A4","B4","C5","D5","E5","F#5","G5",
      "D5","E5","C5","B4","A4","G4","A4","B4",
      "C5","D5","B4","C5","A4","B4","G4"
    ];
    const laneMap = (note) => {
      const pitch = note.replace("#","").replace(/[0-9]/g,"");
      if (pitch === "G") return 1;
      if (pitch === "A") return 2;
      if (pitch === "B") return 3;
      if (pitch === "C") return 3;
      if (pitch === "D") return 2;
      if (pitch === "E") return 2;
      if (pitch === "F") return 3;
      return 1;
    };

    function buildPlan(targetSeconds=62){
      const plan = [];
      let t = 0;
      const baseGap = 0.38; // slower + easier
      while (t < targetSeconds){
        for (const n of MELODY){
          plan.push({ note:n, lane: laneMap(n), gap: baseGap });
          t += baseGap;
          if (t >= targetSeconds) break;
        }
        t += 0.30;
      }
      return plan;
    }
    const plan = buildPlan(62);

    // TRACK HELPERS
    function trackParams(){
      const w = cv.getBoundingClientRect().width;
      const h = cv.getBoundingClientRect().height;
      const topY = h * TRACK_TOP_Y_FRAC;
      const botY = h * TRACK_BOT_Y_FRAC;
      const topW = w * TOP_WIDTH_FRAC;
      const botW = w * BOT_WIDTH_FRAC;
      const cx = w / 2;
      return { w, h, cx, topY, botY, topW, botW };
    }
    function laneXAtY(laneIndex, y, tp){
      const t = (y - tp.topY) / (tp.botY - tp.topY);
      const width = tp.topW + (tp.botW - tp.topW) * t;
      const left = tp.cx - width / 2;
      const laneW = width / LANES;
      return { left, laneW, x: left + laneIndex * laneW };
    }
    function yFromS(s, tp){
      const eased = Math.pow(s, 1.35);
      return tp.topY + (tp.botY - tp.topY) * eased;
    }
    function tilePoly(lane, sTop, sBot, tp){
      const y1 = yFromS(sTop, tp);
      const y2 = yFromS(sBot, tp);
      const a1 = laneXAtY(lane, y1, tp);
      const a2 = laneXAtY(lane, y2, tp);
      const inset = 0.08;
      const x1L = a1.x + a1.laneW * inset;
      const x1R = a1.x + a1.laneW * (1 - inset);
      const x2L = a2.x + a2.laneW * inset;
      const x2R = a2.x + a2.laneW * (1 - inset);
      return [{x:x1L,y:y1},{x:x1R,y:y1},{x:x2R,y:y2},{x:x2L,y:y2}];
    }
    function pointInPoly(px, py, poly){
      let inside = false;
      for (let i=0, j=poly.length-1; i<poly.length; j=i++){
        const xi = poly[i].x, yi = poly[i].y;
        const xj = poly[j].x, yj = poly[j].y;
        const intersect = ((yi > py) !== (yj > py)) &&
          (px < (xj - xi) * (py - yi) / (yj - yi + 1e-9) + xi);
        if (intersect) inside = !inside;
      }
      return inside;
    }
    function hitS(tp){
      const yTarget = tp.h * HIT_Y_FRAC;
      let lo = 0, hi = 1;
      for (let i=0;i<18;i++){
        const mid = (lo+hi)/2;
        const y = yFromS(mid, tp);
        if (y < yTarget) lo = mid; else hi = mid;
      }
      return (lo+hi)/2;
    }
    function laneFromXAtHit(xCss, tp){
      const y = tp.h * HIT_Y_FRAC;
      const a = laneXAtY(0, y, tp);
      const left = a.left, laneW = a.laneW;
      const idx = Math.floor((xCss - left) / laneW);
      if (idx < 0 || idx >= LANES) return null;
      return idx;
    }

    // GAME STATE
    let running = false;
    let startedAudio = false;
    let score = 0;
    let startTs = 0;
    let lastTs = 0;
    let stepIdx = 0;
    let nextSpawnAt = 0;
    let tile = null; // { lane, s, note }
    let pointer = { x:-9999, y:-9999 };

    function reset(){
      running = false;
      score = 0;
      speed = 1.0;
      stepIdx = 0;
      nextSpawnAt = 0;
      tile = null;

      scoreEl.textContent = "0";
      spdEl.textContent = "1.00×";
      hudRight.textContent = "Ready";
      noteHint.textContent = "Next note: —";
      stepHint.textContent = "Step: 0";
      currentWindow();

      centerHint.innerHTML =
        `Press <b>Start</b>. Then: <span class="big">${INPUT_MODE === "hover" ? "HOVER" : "Wait,"}</span> until blocks reach the green line.`;

      setStatus("Super easy mode: huge timing + huge acceptance area.", "");
      draw();
    }

    async function start(){
      if (running) return;
      if (!startedAudio){
        await Tone.start();
        startedAudio = true;
      }
      reset();
      running = true;
      startTs = performance.now();
      lastTs = startTs;
      hudRight.textContent = "GO";
      setStatus("Wait, until blocks reach the green line", "ok");
      requestAnimationFrame(loop);
    }

    function end(msg){
      running = false;
      hudRight.textContent = "STOP";
      setStatus(msg + " Press Reset or Start.", "bad");
      if (score > best){
        best = score;
        localStorage.setItem(BEST_KEY, String(best));
        bestEl.textContent = best;
        setStatus(msg + " NEW BEST ✅", "ok");
      }
    }

    document.getElementById("startBtn").addEventListener("click", start);
    document.getElementById("resetBtn").addEventListener("click", reset);

    function spawnNext(){
      if (stepIdx >= plan.length) return;
      const st = plan[stepIdx];
      tile = { lane: st.lane, s: -0.15, note: st.note };
      noteHint.textContent = `Next note: ${st.note}`;
      stepHint.textContent = `Step: ${stepIdx + 1}/${plan.length}`;
      centerHint.innerHTML = (INPUT_MODE === "hover")
        ? '<span class="big">HOVER NOW!</span> (anywhere in highlighted lane)'
        : '<span class="big">TAP NOW!</span> (anywhere in highlighted lane)';
    }

    function scheduleNext(songTimeSec){
      stepIdx++;
      if (stepIdx >= plan.length){
        tile = null;
        running = false;
        hudRight.textContent = "DONE";
        setStatus("Finished! Press Start to replay.", "ok");
        if (score > best){
          best = score;
          localStorage.setItem(BEST_KEY, String(best));
          bestEl.textContent = best;
        }
        return;
      }
      const gap = plan[stepIdx].gap / speed;
      nextSpawnAt = songTimeSec + gap;
      tile = null;
      centerHint.innerHTML = 'Get ready…';
    }

    function registerHit(songTimeSec){
      playNote(tile.note, speed);
      score += 100;
      scoreEl.textContent = String(score);

      speed += speedGain();
      spdEl.textContent = speed.toFixed(2) + "×";
      currentWindow();

      hudRight.textContent = "NICE";
      setTimeout(() => { if (running) hudRight.textContent = "GO"; }, 120);

      scheduleNext(songTimeSec);
    }

    // POINTER
    gameEl.addEventListener("pointermove", (e) => {
      const r = gameEl.getBoundingClientRect();
      pointer.x = e.clientX - r.left;
      pointer.y = e.clientY - r.top;
    });
    gameEl.addEventListener("pointerleave", () => {
      pointer.x = -9999; pointer.y = -9999;
    });

    // TAP MODE: tap anywhere vertically; lane determined only by x
    gameEl.addEventListener("pointerdown", (e) => {
      if (!running || INPUT_MODE !== "tap") return;
      if (!tile) return;

      const r = gameEl.getBoundingClientRect();
      const x = e.clientX - r.left;

      const tp = trackParams();
      const lane = laneFromXAtHit(x, tp);
      if (lane == null) return;

      const sHit = hitS(tp);
      const win = currentWindow();
      const sBot = tile.s + TILE_LENGTH_FRAC;
      const dist = Math.abs(sBot - sHit);

      if (lane === tile.lane && dist <= win){
        const songTimeSec = (performance.now() - startTs) / 1000;
        registerHit(songTimeSec);
      } else {
        end("Wrong lane / wrong timing!");
      }
    });

    // UPDATE
    function update(dt, songTimeSec){
      if (!tile && stepIdx < plan.length && songTimeSec >= nextSpawnAt){
        spawnNext();
      }
      if (!tile) return;

      tile.s += (0.58 * speed) * dt;

      const tp = trackParams();
      const sHit = hitS(tp);
      const win = currentWindow();

      const sTop = tile.s;
      const sBot = tile.s + TILE_LENGTH_FRAC;

      if (INPUT_MODE === "hover"){
        const yHit = tp.h * HIT_Y_FRAC;
        const half = laneAcceptHalfHeight(tp);
        const laneInfo = laneXAtY(tile.lane, yHit, tp);

        const inLaneZone =
          pointer.x >= laneInfo.x &&
          pointer.x <= laneInfo.x + laneInfo.laneW &&
          pointer.y >= (yHit - half) &&
          pointer.y <= (yHit + half);

        const poly = tilePoly(tile.lane, sTop, sBot, tp);
        const onTile = pointInPoly(pointer.x, pointer.y, poly);

        const dist = Math.abs(sBot - sHit);
        if (dist <= win && (inLaneZone || onTile)){
          registerHit(songTimeSec);
          return;
        }
      }

      if (sBot > sHit + win){
        end("Miss!");
        return;
      }
    }

    function loop(ts){
      if (!running){ draw(); return; }
      const dt = Math.min(0.033, (ts - lastTs) / 1000);
      lastTs = ts;
      const songTimeSec = (ts - startTs) / 1000;

      update(dt, songTimeSec);
      draw();
      requestAnimationFrame(loop);
    }

    // DRAW
    function draw(){
      const tp = trackParams();
      ctx.clearRect(0,0,cv.width,cv.height);

      ctx.save();
      ctx.scale(devicePixelRatio, devicePixelRatio);

      // runway
      const topLeft  = { x: tp.cx - tp.topW/2, y: tp.topY };
      const topRight = { x: tp.cx + tp.topW/2, y: tp.topY };
      const botLeft  = { x: tp.cx - tp.botW/2, y: tp.botY };
      const botRight = { x: tp.cx + tp.botW/2, y: tp.botY };

      ctx.beginPath();
      ctx.moveTo(topLeft.x, topLeft.y);
      ctx.lineTo(topRight.x, topRight.y);
      ctx.lineTo(botRight.x, botRight.y);
      ctx.lineTo(botLeft.x, botLeft.y);
      ctx.closePath();
      ctx.fillStyle = "rgba(255,255,255,0.10)";
      ctx.fill();

      ctx.strokeStyle = "rgba(255,255,255,0.25)";
      ctx.lineWidth = 2;
      ctx.stroke();

      // lane lines
      ctx.strokeStyle = "rgba(0,0,0,0.12)";
      ctx.lineWidth = 2;
      for (let i=1;i<LANES;i++){
        const tX = (tp.cx - tp.topW/2) + (tp.topW/LANES)*i;
        const bX = (tp.cx - tp.botW/2) + (tp.botW/LANES)*i;
        ctx.beginPath();
        ctx.moveTo(tX, tp.topY);
        ctx.lineTo(bX, tp.botY);
        ctx.stroke();
      }

      // hit band
      const yHit = tp.h * HIT_Y_FRAC;
      const a = laneXAtY(0, yHit, tp);
      const left = a.left;
      const width = a.laneW * LANES;

      ctx.fillStyle = "rgba(76,175,80,0.16)";
      ctx.fillRect(left, yHit - 30, width, 60);

      ctx.fillStyle = "rgba(255,255,255,0.12)";
      ctx.fillRect(left, yHit - 2, width, 4);

      // tile + HUGE acceptance zone
      if (tile){
        const half = laneAcceptHalfHeight(tp);
        const laneInfo = laneXAtY(tile.lane, yHit, tp);

        // acceptance area (75% height)
        ctx.fillStyle = "rgba(255,255,255,0.07)";
        ctx.fillRect(laneInfo.x, yHit - half, laneInfo.laneW, half*2);

        // tile
        const sTop = tile.s;
        const sBot = tile.s + TILE_LENGTH_FRAC;
        const poly = tilePoly(tile.lane, sTop, sBot, tp);

        ctx.beginPath();
        ctx.moveTo(poly[0].x, poly[0].y);
        for (let i=1;i<poly.length;i++) ctx.lineTo(poly[i].x, poly[i].y);
        ctx.closePath();
        ctx.fillStyle = "rgba(15,15,20,1)";
        ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,0.12)";
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      ctx.restore();
    }

    // init + buttons
    reset();
    document.getElementById("startBtn").addEventListener("click", start);
    document.getElementById("resetBtn").addEventListener("click", reset);
  })();
  </script>
</body>
</html>





